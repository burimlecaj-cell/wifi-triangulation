<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wi-Fi Triangulation — Urban Location Test</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0e1a;
            color: #e0e0e0;
            min-height: 100vh;
            overflow-x: hidden;
        }

        header {
            text-align: center;
            padding: 24px 16px 12px;
        }

        header h1 {
            font-size: 1.4rem;
            font-weight: 700;
            letter-spacing: -0.5px;
            color: #fff;
        }

        header p {
            font-size: 0.8rem;
            color: #8892a4;
            margin-top: 4px;
        }

        /* Source indicator pill */
        #source-pill {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            margin: 12px auto;
            padding: 10px 20px;
            border-radius: 50px;
            font-size: 0.95rem;
            font-weight: 600;
            transition: all 0.4s ease;
            background: #1a1f2e;
            border: 2px solid #2a3040;
        }

        #source-pill .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.8); }
        }

        .source-gps { border-color: #22c55e !important; color: #22c55e; }
        .source-gps .dot { background: #22c55e; box-shadow: 0 0 10px #22c55e88; }

        .source-wifi { border-color: #3b82f6 !important; color: #3b82f6; }
        .source-wifi .dot { background: #3b82f6; box-shadow: 0 0 10px #3b82f688; }

        .source-cell { border-color: #f59e0b !important; color: #f59e0b; }
        .source-cell .dot { background: #f59e0b; box-shadow: 0 0 10px #f59e0b88; }

        .source-unknown { border-color: #6b7280 !important; color: #6b7280; }
        .source-unknown .dot { background: #6b7280; }

        /* Map */
        #map-container {
            width: calc(100% - 32px);
            max-width: 600px;
            margin: 12px auto;
            height: 280px;
            border-radius: 16px;
            overflow: hidden;
            border: 2px solid #1e2433;
            position: relative;
            background: #111827;
        }

        #map {
            width: 100%;
            height: 100%;
            border: none;
        }

        #map-overlay {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #111827;
            color: #6b7280;
            font-size: 0.9rem;
        }

        /* Stats grid */
        #stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            padding: 0 16px;
            max-width: 600px;
            margin: 12px auto;
        }

        .stat-card {
            background: #111827;
            border: 1px solid #1e2433;
            border-radius: 12px;
            padding: 14px;
        }

        .stat-card .label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #6b7280;
            margin-bottom: 6px;
        }

        .stat-card .value {
            font-size: 1.3rem;
            font-weight: 700;
            font-variant-numeric: tabular-nums;
            color: #fff;
        }

        .stat-card .unit {
            font-size: 0.75rem;
            color: #6b7280;
            font-weight: 400;
        }

        .stat-card.wide {
            grid-column: 1 / -1;
        }

        /* Accuracy gauge */
        #gauge-container {
            max-width: 600px;
            margin: 12px auto;
            padding: 0 16px;
        }

        .gauge-card {
            background: #111827;
            border: 1px solid #1e2433;
            border-radius: 12px;
            padding: 16px;
        }

        .gauge-card .label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #6b7280;
            margin-bottom: 10px;
        }

        #accuracy-bar-bg {
            width: 100%;
            height: 8px;
            background: #1e2433;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        #accuracy-bar {
            height: 100%;
            border-radius: 4px;
            transition: width 0.5s ease, background 0.5s ease;
            width: 0%;
        }

        .gauge-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 6px;
            font-size: 0.65rem;
            color: #4b5563;
        }

        /* History chart */
        #history-container {
            max-width: 600px;
            margin: 12px auto;
            padding: 0 16px;
        }

        .history-card {
            background: #111827;
            border: 1px solid #1e2433;
            border-radius: 12px;
            padding: 16px;
        }

        .history-card .label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #6b7280;
            margin-bottom: 10px;
        }

        #history-canvas {
            width: 100%;
            height: 120px;
            display: block;
        }

        /* Log */
        #log-container {
            max-width: 600px;
            margin: 12px auto 24px;
            padding: 0 16px;
        }

        .log-card {
            background: #111827;
            border: 1px solid #1e2433;
            border-radius: 12px;
            padding: 16px;
        }

        .log-card .label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #6b7280;
            margin-bottom: 10px;
        }

        #log {
            max-height: 150px;
            overflow-y: auto;
            font-family: 'SF Mono', 'Fira Code', monospace;
            font-size: 0.72rem;
            line-height: 1.6;
        }

        #log::-webkit-scrollbar { width: 4px; }
        #log::-webkit-scrollbar-track { background: transparent; }
        #log::-webkit-scrollbar-thumb { background: #2a3040; border-radius: 4px; }

        .log-entry { color: #9ca3af; }
        .log-entry .time { color: #4b5563; }
        .log-entry .gps { color: #22c55e; }
        .log-entry .wifi { color: #3b82f6; }
        .log-entry .cell { color: #f59e0b; }

        /* Start button */
        #start-btn {
            display: block;
            margin: 24px auto;
            padding: 14px 40px;
            font-size: 1rem;
            font-weight: 600;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            background: linear-gradient(135deg, #3b82f6, #6366f1);
            color: #fff;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        #start-btn:active { transform: scale(0.97); }
        #start-btn:hover { box-shadow: 0 0 20px #3b82f644; }

        #error-msg {
            text-align: center;
            padding: 16px;
            color: #ef4444;
            font-size: 0.85rem;
            display: none;
        }

        /* Legend strip */
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            padding: 8px 16px 20px;
            font-size: 0.72rem;
            color: #6b7280;
        }

        .legend span {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend .swatch {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
        }
    </style>
</head>
<body>
    <header>
        <h1>Urban Location Triangulation</h1>
        <p>Real-time GPS vs. Wi-Fi vs. Cell Tower detection</p>
    </header>

    <div style="text-align: center;">
        <div id="source-pill" class="source-unknown">
            <span class="dot"></span>
            <span id="source-text">Waiting for signal...</span>
        </div>
    </div>

    <div id="map-container">
        <div id="map-overlay">Waiting for location data...</div>
        <canvas id="map"></canvas>
    </div>

    <div id="stats">
        <div class="stat-card">
            <div class="label">Latitude</div>
            <div class="value" id="lat">—</div>
        </div>
        <div class="stat-card">
            <div class="label">Longitude</div>
            <div class="value" id="lng">—</div>
        </div>
        <div class="stat-card">
            <div class="label">Accuracy</div>
            <div class="value" id="acc">— <span class="unit">m</span></div>
        </div>
        <div class="stat-card">
            <div class="label">Speed</div>
            <div class="value" id="speed">— <span class="unit">m/s</span></div>
        </div>
        <div class="stat-card">
            <div class="label">Altitude</div>
            <div class="value" id="alt">— <span class="unit">m</span></div>
        </div>
        <div class="stat-card">
            <div class="label">Readings</div>
            <div class="value" id="count">0</div>
        </div>
    </div>

    <div id="gauge-container">
        <div class="gauge-card">
            <div class="label">Accuracy Radius</div>
            <div id="accuracy-bar-bg">
                <div id="accuracy-bar"></div>
            </div>
            <div class="gauge-labels">
                <span>1m (GPS)</span>
                <span>50m (Wi-Fi)</span>
                <span>500m+ (Cell)</span>
            </div>
        </div>
    </div>

    <div id="history-container">
        <div class="history-card">
            <div class="label">Accuracy History</div>
            <canvas id="history-canvas"></canvas>
        </div>
    </div>

    <div class="legend">
        <span><span class="swatch" style="background:#22c55e;"></span> GPS (1-15m)</span>
        <span><span class="swatch" style="background:#3b82f6;"></span> Wi-Fi (16-100m)</span>
        <span><span class="swatch" style="background:#f59e0b;"></span> Cell (100m+)</span>
    </div>

    <div id="log-container">
        <div class="log-card">
            <div class="label">Event Log</div>
            <div id="log"></div>
        </div>
    </div>

    <button id="start-btn">Start Tracking</button>
    <div id="error-msg"></div>

    <script>
        // State
        const state = {
            watchId: null,
            readings: 0,
            history: [],          // { time, accuracy, lat, lng }
            maxHistory: 60,
            positions: [],        // last N positions for the mini-map
            maxPositions: 40,
            started: false,
        };

        // DOM refs
        const $ = id => document.getElementById(id);
        const latEl = $('lat'), lngEl = $('lng'), accEl = $('acc');
        const speedEl = $('speed'), altEl = $('alt'), countEl = $('count');
        const sourcePill = $('source-pill'), sourceText = $('source-text');
        const accBar = $('accuracy-bar');
        const logEl = $('log');
        const mapCanvas = $('map');
        const mapOverlay = $('map-overlay');
        const histCanvas = $('history-canvas');
        const startBtn = $('start-btn');
        const errorMsg = $('error-msg');

        // Classify source by accuracy radius
        function classifySource(accuracy) {
            if (accuracy <= 15)  return { label: 'GPS Satellites', cls: 'source-gps', logCls: 'gps' };
            if (accuracy <= 100) return { label: 'Wi-Fi Triangulation', cls: 'source-wifi', logCls: 'wifi' };
            return { label: 'Cell Tower', cls: 'source-cell', logCls: 'cell' };
        }

        function sourceColor(accuracy) {
            if (accuracy <= 15)  return '#22c55e';
            if (accuracy <= 100) return '#3b82f6';
            return '#f59e0b';
        }

        // Logging
        function addLog(msg, cls) {
            const t = new Date().toLocaleTimeString();
            const div = document.createElement('div');
            div.className = 'log-entry';
            div.innerHTML = `<span class="time">${t}</span> — <span class="${cls}">${msg}</span>`;
            logEl.prepend(div);
            // Keep log manageable
            while (logEl.children.length > 50) logEl.removeChild(logEl.lastChild);
        }

        // Update accuracy gauge
        function updateGauge(accuracy) {
            // Log scale: map 1-1000m onto 0-100%
            const minLog = Math.log10(1);
            const maxLog = Math.log10(1000);
            const pct = Math.min(100, Math.max(0,
                ((Math.log10(Math.max(1, accuracy)) - minLog) / (maxLog - minLog)) * 100
            ));
            accBar.style.width = pct + '%';
            accBar.style.background = sourceColor(accuracy);
        }

        // Draw accuracy history chart
        function drawHistory() {
            const canvas = histCanvas;
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            const ctx = canvas.getContext('2d');
            ctx.scale(dpr, dpr);
            const W = rect.width, H = rect.height;

            ctx.clearRect(0, 0, W, H);

            if (state.history.length < 2) return;

            const data = state.history;
            const maxAcc = Math.max(100, ...data.map(d => d.accuracy));

            // Grid lines
            ctx.strokeStyle = '#1e2433';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = (i / 4) * H;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(W, y);
                ctx.stroke();
            }

            // Threshold lines
            // GPS/Wi-Fi boundary at 15m
            const y15 = H - (15 / maxAcc) * H;
            ctx.strokeStyle = '#22c55e33';
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            ctx.moveTo(0, y15);
            ctx.lineTo(W, y15);
            ctx.stroke();
            ctx.setLineDash([]);

            // Wi-Fi/Cell boundary at 100m
            const y100 = H - (100 / maxAcc) * H;
            if (y100 > 0) {
                ctx.strokeStyle = '#3b82f633';
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(0, y100);
                ctx.lineTo(W, y100);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Draw line
            ctx.lineWidth = 2;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';

            for (let i = 1; i < data.length; i++) {
                const x0 = ((i - 1) / (state.maxHistory - 1)) * W;
                const x1 = (i / (state.maxHistory - 1)) * W;
                const y0 = H - (data[i - 1].accuracy / maxAcc) * H;
                const y1 = H - (data[i].accuracy / maxAcc) * H;

                ctx.strokeStyle = sourceColor(data[i].accuracy);
                ctx.beginPath();
                ctx.moveTo(x0, y0);
                ctx.lineTo(x1, y1);
                ctx.stroke();
            }

            // Dots
            for (let i = 0; i < data.length; i++) {
                const x = (i / (state.maxHistory - 1)) * W;
                const y = H - (data[i].accuracy / maxAcc) * H;
                ctx.fillStyle = sourceColor(data[i].accuracy);
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Draw mini-map showing position trail
        function drawMap() {
            if (state.positions.length === 0) return;
            mapOverlay.style.display = 'none';

            const canvas = mapCanvas;
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            const ctx = canvas.getContext('2d');
            ctx.scale(dpr, dpr);
            const W = rect.width, H = rect.height;

            ctx.fillStyle = '#111827';
            ctx.fillRect(0, 0, W, H);

            const positions = state.positions;
            const last = positions[positions.length - 1];

            // If only one point, just draw it centered
            if (positions.length === 1) {
                drawCrosshairs(ctx, W, H);
                drawPositionDot(ctx, W / 2, H / 2, last.accuracy, true);
                drawCoordLabel(ctx, W, H, last);
                return;
            }

            // Compute bounds with padding
            let minLat = Infinity, maxLat = -Infinity;
            let minLng = Infinity, maxLng = -Infinity;
            for (const p of positions) {
                minLat = Math.min(minLat, p.lat);
                maxLat = Math.max(maxLat, p.lat);
                minLng = Math.min(minLng, p.lng);
                maxLng = Math.max(maxLng, p.lng);
            }

            // Ensure minimum range so single-location doesn't break
            const latRange = Math.max(maxLat - minLat, 0.0005);
            const lngRange = Math.max(maxLng - minLng, 0.0005);
            const padding = 40;

            function project(lat, lng) {
                const x = padding + ((lng - (minLng - lngRange * 0.1)) / (lngRange * 1.2)) * (W - 2 * padding);
                const y = padding + ((1 - (lat - (minLat - latRange * 0.1)) / (latRange * 1.2))) * (H - 2 * padding);
                return [x, y];
            }

            // Grid
            drawCrosshairs(ctx, W, H);

            // Trail line
            ctx.lineWidth = 2;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            for (let i = 1; i < positions.length; i++) {
                const [x0, y0] = project(positions[i - 1].lat, positions[i - 1].lng);
                const [x1, y1] = project(positions[i].lat, positions[i].lng);
                const alpha = 0.2 + 0.8 * (i / positions.length);
                ctx.strokeStyle = sourceColor(positions[i].accuracy) + Math.round(alpha * 255).toString(16).padStart(2, '0');
                ctx.beginPath();
                ctx.moveTo(x0, y0);
                ctx.lineTo(x1, y1);
                ctx.stroke();
            }

            // Position dots
            for (let i = 0; i < positions.length; i++) {
                const [x, y] = project(positions[i].lat, positions[i].lng);
                const isLast = i === positions.length - 1;
                drawPositionDot(ctx, x, y, positions[i].accuracy, isLast);
            }

            drawCoordLabel(ctx, W, H, last);
        }

        function drawCrosshairs(ctx, W, H) {
            ctx.strokeStyle = '#1e243388';
            ctx.lineWidth = 1;
            ctx.setLineDash([6, 6]);
            ctx.beginPath();
            ctx.moveTo(W / 2, 0); ctx.lineTo(W / 2, H);
            ctx.moveTo(0, H / 2); ctx.lineTo(W, H / 2);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function drawPositionDot(ctx, x, y, accuracy, isCurrent) {
            const color = sourceColor(accuracy);
            if (isCurrent) {
                // Accuracy radius ring
                const radiusPx = Math.min(60, Math.max(12, accuracy * 0.8));
                ctx.fillStyle = color + '18';
                ctx.strokeStyle = color + '44';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(x, y, radiusPx, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Center dot
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(x, y, 6, 0, Math.PI * 2);
                ctx.fill();

                // White inner
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            } else {
                ctx.fillStyle = color + '88';
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawCoordLabel(ctx, W, H, pos) {
            ctx.fillStyle = '#4b5563';
            ctx.font = '11px -apple-system, sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(`${pos.lat.toFixed(6)}, ${pos.lng.toFixed(6)}`, 8, H - 8);
            ctx.textAlign = 'right';
            ctx.fillText(`~${pos.accuracy.toFixed(0)}m radius`, W - 8, H - 8);
        }

        // Main success callback
        function onPosition(pos) {
            const { latitude, longitude, accuracy, speed, altitude } = pos.coords;
            state.readings++;

            const src = classifySource(accuracy);

            // Update pill
            sourcePill.className = src.cls;
            sourceText.textContent = src.label;

            // Update stats
            latEl.textContent = latitude.toFixed(6);
            lngEl.textContent = longitude.toFixed(6);
            accEl.innerHTML = `${accuracy.toFixed(1)} <span class="unit">m</span>`;
            speedEl.innerHTML = speed != null ? `${speed.toFixed(1)} <span class="unit">m/s</span>` : `— <span class="unit">m/s</span>`;
            altEl.innerHTML = altitude != null ? `${altitude.toFixed(0)} <span class="unit">m</span>` : `— <span class="unit">m</span>`;
            countEl.textContent = state.readings;

            // Gauge
            updateGauge(accuracy);

            // History
            state.history.push({ time: Date.now(), accuracy, lat: latitude, lng: longitude });
            if (state.history.length > state.maxHistory) state.history.shift();
            drawHistory();

            // Positions for map
            state.positions.push({ lat: latitude, lng: longitude, accuracy });
            if (state.positions.length > state.maxPositions) state.positions.shift();
            drawMap();

            // Log
            addLog(`${src.label} — ${accuracy.toFixed(1)}m accuracy`, src.logCls);
        }

        function onError(err) {
            const messages = {
                1: 'Location permission denied. Please allow location access and reload.',
                2: 'Position unavailable. Make sure location services are enabled.',
                3: 'Location request timed out. Retrying...',
            };
            const msg = messages[err.code] || err.message;
            errorMsg.textContent = msg;
            errorMsg.style.display = 'block';
            addLog('Error: ' + msg, 'cell');
        }

        function startTracking() {
            if (state.started) return;
            state.started = true;
            startBtn.textContent = 'Tracking...';
            startBtn.style.opacity = '0.6';
            startBtn.style.cursor = 'default';

            errorMsg.style.display = 'none';
            addLog('Tracking started — waiting for first fix...', 'wifi');

            const options = {
                enableHighAccuracy: true,
                timeout: 15000,
                maximumAge: 0,
            };

            state.watchId = navigator.geolocation.watchPosition(onPosition, onError, options);
        }

        startBtn.addEventListener('click', startTracking);

        // Handle resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                drawHistory();
                drawMap();
            }, 150);
        });
    </script>
</body>
</html>
